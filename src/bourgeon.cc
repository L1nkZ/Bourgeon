#include "bourgeon.h"

#include <Windows.h>

#include "imgui.h"
#include "utils/log_console.h"

Bourgeon::Bourgeon()
    : interpreter_(),
      callbacks_(),
      last_tick_count_(),
      log_lines_(),
      client_(),
      loaded_plugins_() {}

RagnarokClient& Bourgeon::client() { return client_; }

bool Bourgeon::Initialize() {
  LogInfo("Bourgeon {}\n", BOURGEON_VERSION);

  if (!client_.Initialize()) {
    LogError("Bourgeon failed to initialize");
    return false;
  }

  LogInfo("Bourgeon initialized successfully!");
  LoadPlugins("./plugins");

  return true;
}

void Bourgeon::OnTick() {
  // Only run once every 100ms (6 frames at 60fps)
  const auto current_tick_count = GetTickCount();
  if (current_tick_count >= last_tick_count_ &&
      current_tick_count <= last_tick_count_ + 100) {
    return;
  }
  last_tick_count_ = current_tick_count;

  for (auto& registree : callbacks_["OnTick"]) {
    try {
      registree();
    } catch (pybind11::error_already_set& error) {
      LogError(error.what());
      UnregisterCallback("OnTick", registree);
    }
  }
}

void Bourgeon::AddLogLine(std::string log_line) {
  log_lines_.emplace_back(std::move(log_line));
}

void Bourgeon::RenderUI() const {
#ifdef BOURGEON_DEBUG
  ImGui::ShowDemoWindow();
#endif  // BOURGEON_DEBUG

  ShowBourgeonWindow();
}

void Bourgeon::RegisterCallback(const std::string& callback_name,
                                const pybind11::object& function) {
  try {
    LogInfo("{} has been registered to {}",
            function.attr("__name__").cast<std::string>(), callback_name);
  } catch (pybind11::error_already_set& error) {
    LogError("{}", error.what());
  }
  callbacks_[callback_name].push_back(function);
}

void Bourgeon::UnregisterCallback(const std::string& callback_name,
                                  const pybind11::object& function) {
  for (auto it = callbacks_[callback_name].begin();
       it != callbacks_[callback_name].end(); ++it) {
    if (function.ptr() == it->ptr()) {
      callbacks_[callback_name].erase(it);
      LogInfo("{} has been unregistered from {}",
              function.attr("__name__").cast<std::string>(), callback_name);
      break;
    }
  }
}

const std::vector<pybind11::object>& Bourgeon::GetCallbackRegistrees(
    const std::string& callback_name) {
  return callbacks_[callback_name];
}

void Bourgeon::LoadPlugins(const std::string& folder) {
  using namespace pybind11;

  std::string search_path = folder + "/*.py";
  WIN32_FIND_DATA fd;
  HANDLE h_find = FindFirstFileA(search_path.c_str(), &fd);

  if (h_find == INVALID_HANDLE_VALUE) {
    return;
  }

  do {
    if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
      continue;
    }

    std::string filename(fd.cFileName);
    LogInfo("Loading {}", filename);
    try {
      eval_file(folder + '/' + filename,
                module::import("__main__").attr("__dict__"));
      loaded_plugins_.emplace_back(std::move(filename));
    } catch (error_already_set& error) {
      LogError("{}", error.what());
    }
  } while (FindNextFileA(h_find, &fd));

  FindClose(h_find);
}

void Bourgeon::ShowBourgeonWindow() const {
  ImGui::Begin("Bourgeon");

  // List of successfully loaded plugins
  if (ImGui::CollapsingHeader("Loaded plugins")) {
    for (auto& plugin_name : loaded_plugins_) {
      ImGui::BulletText("%s", plugin_name.c_str());
    }
  }

  // Logs generated by plugins
  if (ImGui::CollapsingHeader("Logs")) {
    ImGui::BeginChild("scrolling", ImVec2(0, 0), false,
                      ImGuiWindowFlags_HorizontalScrollbar);
    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
    // Clipped lines
    ImGuiListClipper clipper;
    clipper.Begin(log_lines_.size());
    while (clipper.Step()) {
      for (int line_no = clipper.DisplayStart; line_no < clipper.DisplayEnd;
           line_no++) {
        ImGui::TextUnformatted(log_lines_[line_no].c_str());
      }
    }
    clipper.End();
    ImGui::PopStyleVar();

    // Auto-scroll when at the bottom
    if (ImGui::GetScrollY() >= ImGui::GetScrollMaxY())
      ImGui::SetScrollHereY(1.0f);

    ImGui::EndChild();
  }

  ImGui::End();
}
